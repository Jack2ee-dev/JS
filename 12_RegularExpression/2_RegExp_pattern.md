## 리터럴 문자

정규 표현식의 패턴은 일반 문자와 메타 문자로 구성되어 있습니다. 일반 문자는 리터럴 문자라고 합니다. 자바스크립트의 정규 표현식 패턴에서 사용할 수 있는 리터럴 문자는 아래와 같습니다.
**유니코드 문자**: 문자 그 자체를 뜻한다. 단 **^, \$, \, .,\, \*, +, ?, (, ), [, ], {, }, |**는 제외한다.
**\0**: NULL 문자
**\n**: 개행 문자
**\t**: 탭 문자
**\v**: 수직 탭 문자
**\f**: 다음 페이지 문자
**\r**: 캐리지 리턴 문자
**\xhh**: 16진수 hh로 지정된 ASCII 문자
**\uhhhh**: 16진수 hhhh로 지정된 유니코드 문자
**\cx**: 제어 문자

다음 문자는 정규 표현식에서 특별한 뜻을 갖는 메타 문자입니다.
**^, \$, \, ., \, \*, +, ?, (, ), [, ], {, }, |**
이 메타 문자를 문자로 표기할 때는 메타 문자 앞에 \ 문자를 붙여서 이스케이프합니다. 예를 들어 마침표를 문자로 표기할 때는 '\.'라고 작성합니다. 이외에 자바스크립트 정규 표현식 패턴에서 이스케이프가 필요한 문자로는 / 문자가 있습니다.

```
패턴 문자열을 RegExp 생성자의 인수로 넘겨서 정규 표현식 객체를 생성할 때는 \ 문자를 표기할 때 유의해야 합니다. 이는 자바스크립트의 정규 표현식 엔진이 문자열에서 \ 문자 다음에 뒤따라오는 문자가 이스케이프 시퀀스의 구성 요소가 아니라고 판단하면 \ 문자를 무시해 버리기 때문입니다.
console.log('\abcd\e'); // -> 'abcde'
예를 들어 정규 표현식 리터럴로 다음과 같은 정규 표현식 객체를 생성해 봅니다.
var reg = /\d+/;
이는 '한 개 이상의 숫자가 나열됨'이라는 패턴입니다. 앞의 패턴을 RegExp 생성자로 생성하려면 다음과 같이 \ 문자를 투 번 표기해야 합니다.
var reg = new RegExp('\\d+');
```

## 문자 클래스: [...]

1. 문자 클래스
   문자 클래스는 특정 문자 집합 안의 모든 단일 문자와 일치합니다. 문자 클래스를 정의하려면 문자 집합의 요소가 되는 문자 리터럴을 나열하여 대괄호로 묶어 줍니다.
   예)
   [abc]: 이 정규 표현식은 'a', 'b', 'c' 중 문자 한 개와 일치합니다. 또한 [0123456789]는 숫자로 해석될 수 있는 문자 한 개와 일치합니다.

```
console.log(/[0123456789]/.test('10 little indians')); // -> true
```

문자 클래스인 대괄호 안에서 하이픈(-)을 사용하면 문자의 범위를 지정할 수 있습니다.
[a-z] // 전체 소문자 중 문자 한 개
[abcx-z] // [a][b] [c][x] [y][z] 중 문자 한 개
[a-zA-Z0-9] // 모든 알파벳과 숫자 중 문자 한 개

- 문자는 그 앞뒤 문자가 모두 리터럴 문자일 때만 범위라는 뜻을 갖습니다. 그렇지 않을 때는 - 문자 자체라는 뜻이 됩니다.

2. 부정 문자 클래스: [^...]

[^...]는 [...]의 여집합의 문자 한 개와 일치합니다. 대괄호 안의 패턴이 ^으로 시작하지 않으면 ^을 ^문자로 인식합니다.

## 문자 클래스의 단축 표기

1. 임의의 문자 한 개: .
   마침표(.)는 줄 바꿈 문자를 제외한 임의의 문자 한 개와 일치합니다.

```
/c.t/ // 'cat', 'cute' 등과 일치함. 'action', 'condition'과는 일치하지 않음
/c..l/ / 'hot and cool' 등과 일치함. 'cols', 'console'과는 일치하지 않음
```

2. 숫자와 숫자 외의 문자: \d, \D

```
var dateTime = /\d\d\d\d-\d\d-\d\d \d\d:\d\d/;
console.log(dateTime.test("it's 2016-08-27 10:15")); // -> true
```

3. 단어 문자와 단어 문자 외의 문자: \w, \W
   \w는 모든 영어 단어 문자(알파벳, 숫자, 언더스코어)라는 뜻입니다. 즉, \w는 [a-zA-Z0-9]의 단축 표기입니다. \W는 [^a-za-z0-9]의 단축 표기입니다.

4. 공백 문자와 공백 문자 외의 문자: \s, \S
   \s는 모든 공백 문자(공백 문자, 탭 문자, 개행 문자 등)와 일치합니다. \S는 공백 문자가 아닌 문자와 일치합니다.

5. 문자 클래스 안에서의 이스케이프
   앞서 설명한 \ 문자가 붙어 있는 단축 표기는 대괄호 안에 문자 클래스를 작성할 때도 같은 뜻으로 사용할 수 있습니다. 예를 들어 [\s\w]는 공백 문자 한 개 또는 영어 단어 문자 중 문자 한 개와 일치합니다. 다음 메타 문자를 문자 클래스 안에서 사용하면 메타 문자로서의 특별한 의미를 잃고 그 문자 자체를 뜻하게 됩니다.
   **\$ . \* + ? ( ) [ { } |**
   단, 다음의 메타 문자를 원래 문자로 사용할 때는 \ 문자를 앞에 붙여서 이스케이프해야 합니다.
   **] \ -**

## 반복 패턴

1. 최소 m번, 최대 n번 반복: {m, n}

2. 바로 앞의 요소를 최소 n번 반복: {n,}

3. 바로 앞의 요소를 n번 반복: {n}

4. 최대 한 번 반복: ?

```
/[a-z]{4}\d?/ // 알파벳 소문자가 네 자 등장하고 그 뒤에 숫자가 없거나 한 개인 문자열과 일치
```

5. 최소 한 번 반복: +

```
/\s+Tom\s+/ // [Tom]의 바로 앞뒤에 공백 문자가 최소 한 자 이상 등장
```

6. 최소 0번 반복: \*

```
/[a-z]{4}\d*/ // 알파벳 소문자가 네 자 등장하고, 그 뒤에 숫자가 0개 이상 등장하는 문자열과 일치
```

7. 욕심 없는 반복: 반복 문자 ?
   반복 처리를 하는 메타 문자는 주어진 문자열을 가능한 최대 횟수만큼 반복해서 매칭합니다.

```
console.log(/Java.*/.exec('I love JavaScript')); // -> ['JavaScript']
```

즉, \*는 .(임의의 문자)를 가능한 최대 횟수만큼 일치한 결과를 반환한다는 사실을 알 수 있습니다. 이러한 반복을 가리켜 '욕심 많은 반복'이라고 합니다. 이와는 반대로 최소한으로 반복하는 '욕심 없는 반복'을 지정할 수도 있습니다. 욕심 없는 반복을 지정하려면 반복을 지정하는 문자 뒤에 ?를 붙여 줍니다.

```
console.log(/Java.*?/.exec('I love JavaScript')); // -> ['Java']
```

## 그룹화와 참조

1. 그룹화: (...)
   정규 표현식의 패턴 요소를 소괄호로 묶으면 부분적으로 그룹화할 수 있습니다. 그룹화한 부분은 ?, +, \* 등을 사용해서 반복할 수도 있고, 나중에 언급할 |을 사용해서 선택의 범위를 좁힐 수도 있습니다.

```
var bark = /bow+(woo+f)+/;
console.log(bark.test('bowwoofwoofwooofwoooof')); // -> true
```

이 예은 정규 표현식 bark에서 첫 번째 +는 그 앞의 w를 반복합니다. 그리고 두 번째 +는 앞의 o를 반복합니다. 세 번째 +는 소괄호 안의 요소를 반복합니다.
또한 그룹화된 부분(소괄호로 묶은 부분)은 부분 정규 표현식이 됩니다. 이 **부분 정규 표현식**과 일치한 값은 별도로 저장되므로 나중에 그 부분을 다시 참조할 수 있습니다. 이렇게 일치한 값을 저장하는 동작을 가리켜 **캡처링**(저장)이라고 합니다.

```
var header1 = /<h[1-6]>.*<\/h[1-6]>/;
console.log(header1.test('<h1>JavaScript</h1>')); // -> true
console.log(header1.test('<h1>JavaScript</h2>')); // -> true

var header2 = /<h[1-6]>.*<\/\1>/;
console.log(header2.test('<h1>JavaScript</h1>')); // -> true
console.log(header2.test('<h1>JavaScript</h2>')); // -> false
```

\1은 첫 번째 부분 정규 표현식을 참조합니다. 이때 \1의 패턴을 참조하는 것이 아니라 부분 정규 표현식과 일치한 값을 참조한다는 점이 중요합니다. 즉, (h[1-6])가 h1과 일치하면 \1이 h1에만 일치하게 됩니다. 마찬가지로 \2는 두 번째 부분 정규 표현식의 값을 참조하며 \n은 n번째 부분 정규 표현식의 값을 참조합니다.

2. 캡처링 없는 그룹화: (?:...)

## 위치를 기준으로 매칭하기

문자열의 위치를 패턴으로 지정하는 **앵커**라는 문자가 있습니다.

1. 문자열의 시작 위치: ^
   ^은 문자열의 시작 위치에 패턴을 고정합니다.

```
var jsFirst = /^JavaScript/;
console.log(jsFirst.test('JavaScript is powerful')) // -> true
console.log(jsFirst.test('I love JavaScript')) // -> false
```

2. 문자열의 마지막 위치: \$

```
var jsFirst = /JavaScript$/;
console.log(jsFirst.test('JavaScript is powerful')) // -> false
console.log(jsFirst.test('I love JavaScript')) // -> true
```

3. 영어 단어의 경계: \b
   /\scat\s/라는 정규 표현식으로 영어 문장 안에서 'cat'이라는 단어를 검색하는 상황을 예로 들어 보겠습니다. 'cat'은 문장 중간에 있다면 /\scat\s/ 패턴으로 찾아낼 수 있습니다. 하지만 이 문장이 앞이나 뒤에 있는 cat은 찾아낼 수 없습니다. 공백 문자가 그 문장의 앞부분과 뒷부분에 없기 때문입니다. 이때는 \b를 사용합니다. \b는 영어 단어의 경계 위치와 일치합니다.

4. 영어 단어 경계 외의 위치: \B

```
/\Bdog/ // 'Bulldog'와 일치한다. 'dog'나 'I love dog'와는 일치하지 않는다.
```

5. 전방 탐색: (?=pattern)
   x(?=y)라고 표기하면 x 다음에 y가 나오는 패턴이 됩니다.

```
console.log(/Java(?=Script)/.exec('JavaScript)); // -> ['JavaScript']
console.log(/Java(?=Script)/.exec('JavaCoffee)); // -> null
```

6. 전방 부정 탐색: (?!pattern)
   x(?!y)라고 표기하면 x 다음에 y가 나오지 않는 패턴이 됩니다.

```
console.log(/Java(!=Script)/.exec('JavaScript)); // -> null
console.log(/Java(?=Script)/.exec('JavaCoffee)); // -> ['Java']
```

## 선택 패턴

선택 패턴은 문자열 여러 개 중에서 문자열 하나와 일치합니다. 선택 패턴을 정의할 때는 후보가 되는 패턴 문자열을 |로 연결해서 표기합니다.

```
var countFruits = /\b(\d+) (apple|peach|orange)s?\b/;
console.log(countFruits.exec('10 apples')); // -> ['10 apples', '10', 'apple']
```

## 플래그

- i : 대문자와 소문자를 구별하지 않는다.

```
console.log(/\bcat\b/i.test('I like Cat')); // -> true
console.log(/\bcat\b/i.test('I like CAT')); // -> true
```

- g : 전역 검사합니다. 처음뿐만 아니라 일치하는 모든 것을 검색한다.
- m : 여러 줄 모드로 검색한다. 앵커 문자 ^과 \$는 각각 행의 시작과 끝이라는 뜻이다.

```
var reg = /^cat/im;
console.log(res.test('Dog\nCat\nMonkey)); // -> true
var reg = /at$/im;
console.log(res.test('Dog\nCat\nMonkey)); // -> true
```

- y : 시작 위치 고정 검색을 한다.
- u : 정규 표현식 패턴을 내부적으로 유니코드 코드 포인트 열로 처리한다.
