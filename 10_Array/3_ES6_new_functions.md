## 비구조화 할당(Destructuring)

비구조화 할당은 배열, 객체, 반복 가능 객체에서 값을 꺼내어 그 값을 별도의 변수에 대입하는 문장입니다. 객체의 타입별로 비구조화 할당은 다음과 같습니다.

1. 배열의 비구조화 할당

- 기본 예)

```
var [a, b] = [1, 2]; // var a = 1, b = 2와 같음
var [a, b] = [2*a, 2*b]; // a = 2*a, b = 2*b와 같음
```

이때 우변 값의 개수와 좌변 변수의 개수가 같을 필요는 없습니다. 좌변의 변수 개수가 우변의 값 개수보다 많으면 좌변의 남는 변수에는 undefined가 값으로 할당됩니다. 우변의 값 개수가 좌변의 변수 개수보다 많으면 남은 값은 무시됩니다. 또한 변수가 없는 인덱스 값도 무시됩니다.

```
var array, first, second;
array = [first, second] = [1,2,3,4]; // -> first = 1, seconde = 2; array = [1,2,3,4]와 같음
```

- 나머지 요소: 함수의 나머지 매개변수와 마찬가지로 전개 연산자인 ...을 사용하여 나머지 요소를 이용할 수 있습니다.

```
[a, b, ...rest] = [1,2,3,4]; // a = 1, b = 2, rest = [3,4]와 같음
```

- 요소의 기본값: 배열의 비구조화 할당을 할 때는 함수의 인수와 마찬가지로 기본값을 설정할 수 있습니다. 비구조화 할당하는 좌변의 변수에 undefined가 할당되면 undefined 대신에 기본값을 할당합니다.

```
[a=0, b=1, c=2] = [1,2]; // a = 1, b = 2, c = 2와 같음
```

- 함수가 배열로 반환한 값을 비구조화 할당받기

```
function rotation(x, y, theta) {
  var s = Math.sin(theta), c = Math.cos(theta);
  return [c*x - s*y, s*x + c*y];
}
var [a, b] = rotation(1,2,Math.PI/3);
```

2. 객체의 비구조화 할당(Object Destructuring)

- 기본

```
var {a: x, b: y} = {a: 1, b: 2}; // -> x = 1, y = 2와 같음
```

위의 코드에서 좌변에 변수 x, y가 선언되며, 이 변수에는 각각 우변의 a 프로퍼티의 값과 b 프로퍼티의 값이 할당됩니다.

좌변의 변수에 호은하는 프로퍼티 이름이 오른쪽에 없으면 그 변수에는 undefined가 할당됩니다.

```
{a: x, b: y} = {a: 1, c: 2}; // x = 1, y = undefined와 같음
```

우변에 값이 있지만 그에 대응하는 이름의 변수가 좌변에 없으면 무시됩니다.

```
{a: x, b: y} = {a: 1, b: 2, c: 3}; // x = 1, y = 2와 같음. 3은 무시됨
```

```
var {sin: sin, cos: cos, tan: tan, PI: PI} = Math; // var sin = Math.sin, cos = Math.cos, tan = Math.tan, PI = Math.PI와 같음
```

- 프로퍼티의 기본값
  배열의 비구조화 할당을 할 때는 함수의 인수와 마찬가지로 기본값을 설정할 수 있습니다. 비구조화 할당하는 좌변의 변수에 undefined가 할당되면 그 대신에 기본값을 할당합니다.

- 프로퍼티 이름 생략하기
  좌변에는 변수 이름만 쉼표로 구분해서 작성할 수 있습니다. 이때는 프로퍼티 이름이 변수의 이름이 됩니다.

```
{a, b} = {a: 1, b: 2}; // {a: a, b: b} = {a: 1, b: 3}와 같음
var {sin, cos, tan, PI} = Math; // var sin = Math.sin, cos = Math.cos, tan = Math.tan, PI = Math.PI와 같음
```

- 반복 가능한 객체의 비구조화 할당
  우변에 반복 가능한(이터러블한) 객체가 있을 때도 비구조화 할당을 할 수 있습니다. 이때 좌변에는 배열 리터럴과 비슷한 문법을 사용합니다.

```
var [a, b, c] = 'ABC'; // a = 'A', b = 'B', c = 'C'와 같음
function* createNumbers(from, to) {
  while (from <= to) yield from++;
}
var [a,b,c,d,e] = createNumbers(10, 15); // -> a = 10, b = 11, c = 12, d = 13, e = 14와 같음
```

- 중첩된 자료 구조와 비구조화 할당

```
var [a, [b, c]] = [1, [2, 3]]; // -> a = 1, b = 2, c = 3과 같음
```

## 전개연산자

... 은 전개 연산자(spread operator)라고 합니다. 전개 연산자는 반복 가능한(이터러블한) 객체를 반환하는 표현식 앞에 표기하며, 이를 통해 반복 가능한 객체를 배열 리터럴 또는 함수의 인수 목록으로 펼칠 수 있습니다.

```
[... 'ABC'] // -> ['A', 'B', 'C']
f(... 'ABC') // -> f('A', 'B', 'C')와 같음
```

다음 코드는 제너레이터가 만든 이터레이터를 배열 리터럴 안에 펼치는 예입니다.

```
function* createNumbers(from, to) {
  while(from <= to>) yield from++;
}
var iter = createNumbers(10, 15);
[...iter]; // -> [10,11,12,13,14,15]
```

다음 코드는 배열 안의 최댓값을 Math.max로 구합니다. Math.max는 쉼표로 연결된 숫자 중 최대값을 구하는 메서드입니다.

```
var a = [5,2,3,7,1];
Math.max(... a); // -> 7
```

## ArrayBuffer와 형식화 배열

ArrayBuffer, DataView, 형식화 배열(TypedArray)은 연속된 데이터 영역(버퍼)를 조작하기 위해 만들어진 객체입니다. ArrayBuffer는 버퍼를 확보하며 DataView와 형식화 배열은 버퍼에 뷰를 제공합니다. 버퍼의 뷰는 버퍼를 읽고 쓸 때 사용합니다.

1. ArrayBuffer 생성자
   ArrayBuffer 생성자는 메모리에 고정 길이를 가진(길이가 변하지 않는) 인접한 영역(버퍼)를 확보합니다. 단, ArrayBuffer는 메모리에 영역을 확보하는 역할만 할 뿐 버퍼를 조작하는 메서드는 제공하지 않습니다. 버퍼를 조작하려면 형식화 배열(TypedArray 객체) 또는 DataView 객체를 사용해야 합니다. 다음 코드는 메모리에 1024바이트의 버퍼(ArrayBuffer 객체)를 만듭니다.

```
var buffer = new ArrayBuffer(1024);
buffer.byteLength; // -> 1024
var copy = buffer.slice(3, 6); // 3바이트부터 5바이트까지 일부분을 복사한 새로운 ArrayBuffer 객체가 생성되며, 그 참조가 변수 copy에 할당됩니다.
```

2. 형식화 배열
   자바스크립트 배열은 Array 객체입니다. Array 객체는 배열 요소의 추가와 삭제를 동적으로 할 수 있고 다양한 메서드를 이용할 수 있어 편리하지만 배열 요소를 읽고 쓰는 속도가 느리다는 단점이 있습니다. 형식화 배열(TypedArray 객체)은 ArrayBuffer가 확보한 버퍼를 테이터의 저장 장소로 이용하여 데이터의 빠른 읽기와 쓰기를 구현한 객체입니다. 다음이 Array 객체와의 차이점입니다.

- 형식화 배열 요소의 개수는 한정되어 있다.
- 형식화 배열은 길이가 고정되어 있으며 요소를 추가하거나 삭제할 수 없다.
- 형식화 배열에서는 Array.prototype의 메서드를 사용할 수 없다. 하지만 TypedArray.prototype이 제공하는 메서드는 사용할 수 있다.
- 형식화 배열을 생성하면 모든 요소가 0으로 초기화된다.

## Map

0. 개념
   Map 객체는 데이터를 수집하여 활용하기 위한 객체입니다. 값의 고유한 식별 정보인 '키'와 값의 쌍을 Map 객체 안에 저장해서 사용합니다. Map 객체 안에서 키는 고유한 값입니다. 따라서 Map 객체는 키로 값을 사상(Map)한 객체로 간주합니다. Map 객체는 외부에서 키를 사용하여 원하는 값을 추가/삭제/검색할 수 있습니다. 키와 값의 데이터 타입에는 제한이 없습니다. 객체 타입도 사용할 수 있고 원시 타입도 사용할 수 있습니다.
   Object 객체도 키와 값이 쌍을 이룬 프로퍼티가 모여서 만들어진 것입니다. 그런 의미에서 보면 Map 객체와 비슷해 보입니다. 하지만 Map 객체는 Object 객체와 비교했을 때 다음과 같은 차이점이 있습니다.

- Map 객체에는 데이터를 수집하기 위한 다양한 메서드가 마련되어 있다.
- Object 객체는 키로 문자열만 사용할 수 있지만 Map 객체는 키 타입에 제한이 없다.
- Map 객체는 내부적으로 해시 테이블을 활용하기 때문에 데이터 검색 속도가 빠르다.
- Map 객체는 반복 가능(이터러블)하며 for/of 문으로 순회하면 키와 값으로 구성된 배열을 반환한다. Object는 for/in으로 순회하며 추가적인 조작이 필요하다.
- Map 객체는 데이터 개수를 size 프로퍼틸로 구할 수 있다. 하지만 Object 객체는 프로퍼티 개수를 수동으로 계산해야 한다.

1. Map 객체의 생성

```
var map = new Map();
```

초기 데이터를 인수로 지정해서 생성할 수 있습니다. 이때 초기 데이터는 요소를 두 개 이상 포함한 배열 [키, 값]을 그 값으로 가지는 반복 가능한(이터러블한) 객체입니다.

```
var zip = new Map([['Tom', '123-1234'], ['Huck'
, '123-5678']]); // -> Map(2) { 'Tom' => '131-8634', 'Huck' => '556-0002' }
```

Map 객체 안에 저장된 데이터(키와 값의 쌍)의 개수는 size 프로퍼티로 구할 수 있습니다.

2. Map 객체의 메서드
   Map 객체는 Map.prototype의 프로퍼티와 메서드를 상속받습니다.

- clear(): Map 객체 안에 있는 모든 데이터를 삭제한다.
- delete(key): Map 객체에서 key가 가리키는 데이터를 삭제하고 삭제가 완료되면 true를 반환한다.
- entries(): Map 객체가 가진 데이터(키와 값 쌍) 값을 저장한 이터레이터를 데이터를 삽입한 순서대로 반환한다.
- forEach(_callback_): Map 객체의 모든 데이터를 대상으로 callback 함수를 실행한다. 이때 실행 순서는 데이터가 삽입된 순서이다.
- get(_key_): Map 객체에서 key가 가리키는 데이터를 반환한다.
- has(_key_): Map 객체에서 key가 가리키는 데이터가 있는지 판정한다.
- keys(): Map 객체에서 데이터 키를 값으로 가지는 이터레이터를 반환한다.
- set(_key, value_): Map 객체에 키가 key고 값이 value인 데이터를 추가한다.
- values(): Map 객체에서 데이터 값을 값으로 가지는 이터레이터를 반환한다.

## Set

Set 객체는 중복되지 않는 유일한 데이터를 수집하여 활용하기 위한 객체입니다. Set 객체는 데이터 값의 단순 집합(Set)으로 간주합니다. Set 객체는 외부에서 키를 사용하여 데이터 값을 추가/삭제/검색할 수 있습니다. 값의 데이터 타입에는 제한이 없습니다. 객체 타입도 사용할 수 있고 원시 타입도 사용할 수 있습니다.

1. Set 객체의 생성

```
var set = new Set();
```

초기 데이터 세팅은 다음과 같이 할 수 있습니다.

```
var zip = new Set(['123-4567', '123-5678']);
```

2. Set 객체의 메서드

- add(value): Set 객체에 데이터 값 value를 추가한다.
- clear(): Set 객체 안의 모든 데이터를 삭제한다.
- delete(value): Set 객체에서 value를 값으로 갖는 데이터를 삭제한다.
- values(): Set 객체에서 데이터 값을 값으로 갖는 이터레이터를 반환한다.
- forEach(callback): Set 객체의 모든 데이터를 대상으로 callback 함수를 실행한다.
- has(value): Set 객체에서 value를 값으로 갖는 데이터가 있는지 판별한다.
- keys(), values(): Set 객체에서 데이터 값을 값으로 갖는 이터레이터를 반환한다.
